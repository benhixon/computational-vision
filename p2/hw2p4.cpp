//author:  Ben Hixon
//date:    9-28-2010
//course:  493.69 (Computer Vision)
//description:  HW2, program 4: takes a labeled image and a database, and for each
//		line of the database, looks for an object in the image that matches
//		the one described by that line.  The database format is
//			"label x_bar y_bar a b c theta\n"
//		We use the roundness as generated by the second moments to match objects.
//		Matched objects are drawn with their centroid and orientation line on the
//		output image.
//		The input image is itself labeled, but we don't yet have any information on
//		its objects' centroids and second moments.  That means we have to get that
//		information from the labeled image just like we did in hw2p3.cpp.
//		I describe the math in hw2p3.cpp except for roundness which I describe here.
//use:  to compile: g++ -o p4 hw2p4.cpp Image.cpp Pgm.cpp Line.cpp
//	to run: ./p4 labeled.pgm database.txt recognized.pgm

#include <fstream>
#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include "Image.h"
using namespace std;

void matchObjects(Image* im, char* filename);

//I made an object to hold the image data
class ImageData
{
	public:
	double x_bar, y_bar, a, b, c, theta, rho, roundness;

	ImageData(double x, double y, double a, double b, double c, double th);
	bool matches(ImageData* image2); //returns true if image2 matches this image, by
					 //  comparing the roundness (Emin/Emax).
	void printData();	//display this image data (for debugging)
	void drawCentroid(Image* im);
	void drawOrientationLine(Image* im);
};

int main(int argc, char ** argv){

	char* in_filename;
	char* db_filename;
	char* out_filename;

	if(argc!=4){
		cout<<"USAGE: ./p4 labeled.pgm database.txt recognized.pgm\n";
		exit(1);
	}else{
				
		in_filename = *(argv+1);
		db_filename = *(argv+2);
		out_filename = *(argv+3);
	}

	Image *im = new Image;
	if ( readImage(im,in_filename)!=0 ){
		cout<<"ERROR: Can't read from input\n";
		exit(1);
	}

	matchObjects(im, db_filename);

	if ( writeImage(im,out_filename)!=0 ){
		cout<<"ERROR: Can't write to output\n";
		exit(1);
	}
}

void matchObjects(Image* im, char* filename){
/*(1) First, make a vector of ImageData objects called imagesToMatch.  Each 
	of these objects holds a line from database.txt.
  (2) Then, we'll do something similar to what we did in hw2p3.cpp: we'll
	get all the labels in labeled.pgm, then for each label get the 
	info of its object by integrating.
  (3) For each labeled object, we'll make an ImageData instance.  Then for
	every element of imagesToMatch, we'll call ImageData.matches to compare
	the labeled object to the ImageData in the vector.  If it matches, 
	draw its centroid and line of orientation as in hw2p3. */

	/* (1) Parse file into a vector of ImageData objects */
	vector<ImageData> imagesToMatch;
		
	int label;
	double x_bar, y_bar, a, b, c, theta;
			
	ifstream infile(filename);
	while(infile)
	{
		infile>>label>>x_bar>>y_bar>>a>>b>>c>>theta;
		if (!infile) continue;
		
		imagesToMatch.push_back( ImageData(x_bar,y_bar,a,b,c,theta) );
	}

	/*cout<<"Printing database image info...\n";
	for(int i=0; i<imagesToMatch.size(); i++) 
		( imagesToMatch[i] ).printData();
	cout<<"Done printing database info.\n";  */

	/* (2) Get image data for all labeled images in labeled.pgm */
	int ncols=im->getNCols();
	int nrows=im->getNRows();
	vector<int> labels;

	//get number and value of labels for each object
	for(int i=1; i<nrows-1; i++)
		for(int j=1; j<ncols-1; j++)
		{
			int p=im->getPixel(i,j);
			
			if( p!= 0)
			{			
				bool found=false;				
				for(int k=0; k<labels.size(); k++)
					if(labels[k]==p) 
						found=true; 
				
				if(!found) labels.push_back(p);
			}
		}

	//for each labeled object, get its info
	for(int k=0; k<labels.size(); k++)
	{
		x_bar=y_bar=a=b=c=theta=0.0;		
		long int area = 0;
		double x2=0.0, y2=0.0;	
		double rho=0.0;		
		vector<int> xVals;	
		vector<int> yVals;
		
		//Raster scan: update area, xbar, ybar, and store values for getting a,b, and c later
		for(int i=1; i<nrows-1; i++)
			for(int j=1; j<ncols-1; j++)
				if( labels[k] == im->getPixel(i,j) )
				{
					area++;
					xVals.push_back(i);
					yVals.push_back(j);

					x_bar = x_bar + i;
					y_bar = y_bar + j;
				}

		x_bar = x_bar / double(area);	//divide the integral by the area to get the coordinate
		y_bar = y_bar / double(area);

		//get a,b, and c using previously found x_bar, y_bar, and the stored points
		//I think since xVals and x_bar can be close together, we reduce floating point errors
		//	by multiplying out the RHS expressions instead of subtracting and then multiplying.
		for(int i=0; i<xVals.size(); i++)
		{
			//a = a + ( xVals[i] - x_bar )*( xVals[i] - x_bar );
			a = a + xVals[i]*xVals[i] - 2*x_bar*xVals[i] + x_bar*x_bar;
			
			//b = b + 2*( xVals[i] - x_bar )*( yVals[i] - y_bar );
			b = b + 2*( xVals[i]*yVals[i] - xVals[i]*y_bar - x_bar*yVals[i] + x_bar*y_bar );

			//c = c + ( yVals[i] - y_bar)*(yVals[i] - y_bar );
			c = c + yVals[i]*yVals[i] - 2*yVals[i]*y_bar + y_bar*y_bar;
		}

		//from a, b, and c, get theta:		
		theta = (0.5) * atan2( b, a-c );

		/* (3) For each label, make an ImageData object and check imagesToMatch[] to see if
		it matches any of the images described there.  The matching criteria is described in
		the ImageData class function matches().  */ 
		ImageData imgData(x_bar, y_bar, a, b, c, theta);


		for(int i=0; i<imagesToMatch.size(); i++)
			if( imgData.matches( & imagesToMatch[i]) )
			//draw centroid and line of orientation if match found			
			{
				imgData.drawOrientationLine(im);
				imgData.drawCentroid(im);
			}


/* I used the following lines to test my roundness value by only drawing the centroids of 
either the linear-shaped objects (knife, fork, and spoon) or else the circular object (the 
gear).  The knife is found to have a roundness of 0.00775 and the fork is found to have a roundness
of 0.02075, which makes sense because they are both very linear objects and should have a
roundness value close to 0.  Likewise the spoon which is also quite linear has a roundness of
0.0246, which again makes sense, while the gear which is almost perfectly circular has a 
roundness of 0.989518, which is close to the value of 1 that a perfect circle would have. */

		/*if(imgData.roundness < .1)
			imgData.drawCentroid(im);

		if(imgData.roundness > .9)
			imgData.drawCentroid(im);  */
	}

}


ImageData::ImageData(double x, double y, double a, double b, double c, double th)
{
	x_bar=x;
	y_bar=y;
	this->a=a;
	this->b=b;
	this->c=c;
	theta=th;

	rho = y_bar*cos(theta) - x_bar*sin(theta);
	
	/*roundness is not described in hw2p3.cpp so I will comment it here.
	
	As in Horn p53 and the lecture in class, roundness is the ratio of
	the minimum E to the maximum E, where E is the integral of the square
	of the distance from each point in the object to the object's line of
	orientation.
	
	We know that an expression for E is:
		E == 0.5*(a+c) - 0.5*(a-c)*cos(2*theta) - 0.5*b*sin(2*theta)
	and that 
		sin(2*theta) == b/(sqrt( b*b + (a-c)*(a-c) )
		cos(2*theta) == (a-c)/(sqrt( b*b + (a-c)*(a-c) ).
	where the rhs of the last two expressions can be positive or negative.
	When they are both positive, that gives our minimum E; when they are both
	negative, that gives our maximum E.  So we just plug the positive values and
	then the negative values into our formula for E and take the ratio of the two
	results, and that ratio is the roundness.*/
	
	double Emin, Emax, sin2theta, cos2theta;

	sin2theta = b/sqrt( b*b + (a-c)*(a-c) );
	cos2theta = (a-c)/sqrt( b*b + (a-c)*(a-c) );

	Emin = 0.5*(a+c) - 0.5*(a-c)*cos2theta - 0.5*b*sin2theta;

	sin2theta = -1*sin2theta;	//make negative to get Emax
	cos2theta = -1*cos2theta;

	Emax = 0.5*(a+c) - 0.5*(a-c)*cos2theta - 0.5*b*sin2theta;

	roundness = Emin/Emax;	//this value is rotation-independent, so the objects
				//can be spun around and still have the same ratio of
				//minimum to maximum sums of distances from all points
				//to their line of inertia.
}

bool ImageData::matches(ImageData* image2)
//Two images match if their roundness is very close.
{
	//to compare floating point numbers subtract and compare to a small error value.
	if( abs(this->roundness - image2->roundness)<0.025 )
		return true;		

	else return false;			
}

void ImageData::drawCentroid(Image* im)
//draws centroid as a 9x9 black pixel square around x_bar, y_bar
//(could make the size of the box and the color as parameters)
{	
	for(int i=int(x_bar)-4; i<int(x_bar)+4; i++)
		for(int j=int(y_bar)-4; j<int(y_bar)+4; j++)
			im->setPixel(i,j,0);
}

void ImageData::drawOrientationLine(Image* im)
//draws orientation line
//(could make the length of the line and the color as parameters)
{
	double x2 = x_bar+50;
	double y2 = (x2*sin(theta) + rho)/cos(theta);
	line(im, int(x_bar), int(y_bar), int(x2), int(y2), 255);
}

void ImageData::printData()
//display the image data (for debugging)
{
	cout<<"x_bar: "<<x_bar<<" y_bar: "<<y_bar<<" a: "<<a<<" b: "<<b<<" c: "<<c<<" theta: "<<theta<<" roundness: "<<roundness<<endl;
}
